////////////
// TASK 1 //
////////////

def groverDiffusion[n:!â„•](cand:uint[n]) mfree: uint[n] {
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0 { phase(Ï€); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}
 
def grover[n:!â„•](f:uint[n] !â†’ lifted ğ”¹){
	nIterations:=floor(Ï€/(4Â·asin(2^(-n/2))));
	cand:=0:uint[n];
	for k in [0..n) { cand[k] := H(cand[k]); }
 
	for k in [0..nIterations){
		b := f(cand);
		if b { phase(Ï€); }
		forget(b = f(cand));
		cand:=groverDiffusion(cand);
	}
	return measure(cand);
}
 
def dummy_oracle(x:uint[5]) lifted{
	// TODO: complete the oracle
	return x == 2; // a simple oracle that checks if the input equals 2
}
 
def main() { // run grover on dummy oracle
	return grover(dummy_oracle);
}



////////////
// TASK 2 //
////////////

// generate state |Î¦âºâŸ©
def preparation(){
	// TODO: COMPLETE
}

def alice(Ïˆ:ğ”¹,a:ğ”¹){
	// TODO: COMPLETE
}

def bob(measured_a:!ğ”¹,measured_Ïˆ:!ğ”¹,b:ğ”¹){
	// TODO: COMPLETE
}

def teleportation(Ïˆ:ğ”¹){
	(a,b) := preparation();
	(measured_a, measured_Ïˆ) := alice(Ïˆ,a);
	Ïˆ := bob(measured_a, measured_Ïˆ, b);
	return Ïˆ;
}

def main(){ // tests checking teleportation works correctly
	assert(measure(teleportation(0:ğ”¹))==0); // teleport 0
	assert(measure(H(teleportation(H(0:ğ”¹))))==0); // teleport |+âŸ©
	assert(measure(teleportation(1:ğ”¹))==1); // teleport 1
	assert(measure(H(teleportation(H(1:ğ”¹))))==1); // teleport |-âŸ©
}


////////////////
// SOLUTION 1 //
////////////////

def dummy_oracle(x:uint[5]) lifted{
	return
		 x % 2 == 1 &&
		 10 <= x &&
		 x <= 20 &&
		 x % 5 == 4;
}

def dummy_oracle_explicit(x:uint[5]) lifted{
	x_mod_2 := x % 2;
	x_mod_2_eq_1 := x_mod_2 == 1;
 
	ten_leq_x := 10 <= x;
 
	x_leq_20 := x <= 20;
 
	x_mod_5 := x % 5;
	x_mod_5_eq_4 := x_mod_5 == 4;
 
	two := x_mod_2_eq_1 && ten_leq_x;
	three := two && x_leq_20;
	four := three && x_mod_5_eq_4;
 
	// uncomputation
 
	forget(three = two && x_leq_20);
	forget(two = x_mod_2_eq_1 && ten_leq_x);
 
	forget(x_mod_5_eq_4 = x_mod_5 == 4);
	forget(x_mod_5 = x % 5);
 
	forget(x_leq_20 = x <= 20);
	forget(ten_leq_x = 10 <= x);
 
	forget(x_mod_2_eq_1 = x_mod_2 == 1);
	forget(x_mod_2 = x % 2);
 
	return four;
}

////////////////
// SOLUTION 2 //
////////////////

// generate state |Î¦âºâŸ©
def preparation(){
	// prepare a in state |+âŸ©
	a := H(0:ğ”¹);
  
	// prepare b to obtain state |00âŸ© + |11âŸ© (ignoring normalization)
	b := 0:ğ”¹;
	if a {
		 b := X(b);
	}
 
	return (a,b);
}
 
def alice(Ïˆ:ğ”¹,a:ğ”¹){
	if Ïˆ {
		a := X(a);
	}
 
	Ïˆ := H(Ïˆ);
 
	return (measure(a), measure(Ïˆ));
}
 
def bob(measured_a:!ğ”¹,measured_Ïˆ:!ğ”¹,b:ğ”¹){
	if measured_a {
		b := X(b);
	}
 
	if measured_Ïˆ {
		b := Z(b);
	}
 
	return b;
}
 
def teleportation(Ïˆ:ğ”¹){
	(a,b) := preparation();
	(measured_a, measured_Ïˆ) := alice(Ïˆ,a);
	Ïˆ := bob(measured_a, measured_Ïˆ, b);
	return Ïˆ;
}
 
def main(){ // tests checking teleportation works correctly
	assert(measure(teleportation(0:ğ”¹))==0); // teleport |0âŸ©
	assert(measure(H(teleportation(H(0:ğ”¹))))==0); // teleport |+âŸ©
	assert(measure(teleportation(1:ğ”¹))==1); // teleport |1âŸ©
	assert(measure(H(teleportation(H(1:ğ”¹))))==1); // teleport |-âŸ©
}
